apiVersion: v1
kind: PersistentVolume
metadata:
  name: mongodb-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 20Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: v1
kind: Service
metadata:
    name: mongodb
    labels:
        app: mongodb
spec:
    selector:
        app: mongodb
    ports:
      - protocol: TCP
        port: 27017
        targetPort: 27017
---
apiVersion: apps/v1
kind: Deployment
metadata:
    name: mongodb
    labels:
        app: mongodb
spec:
    replicas: 1
    selector:
        matchLabels:
            app: mongodb
    strategy:
        type: Recreate
    template:
        metadata:
            labels:
                app: mongodb
        spec:
            containers:
              - name: mongodb
                image: mongo
                imagePullPolicy: IfNotPresent
                ports:
                  - containerPort: 27017
                volumeMounts:
                  - name: mongodb-data
                    mountPath: /data/db/
            volumes:
              - name: mongodb-data
                persistentVolumeClaim:
                    claimName: mongodb-pv-claim
---
apiVersion: v1
kind: Service
metadata:
    name: redis
    labels:
        app: redis
spec:
    selector:
        app: redis
    ports:
      - protocol: TCP
        port: 6379
        targetPort: 6379
---
apiVersion: apps/v1
kind: Deployment
metadata:
    name: redis
    labels:
        app: redis
spec:
    replicas: 1
    selector:
        matchLabels:
            app: redis
    template:
        metadata:
            labels:
                app: redis
        spec:
            containers:
              - name: redis
                image: redis
                imagePullPolicy: IfNotPresent
                ports:
                  - containerPort: 6379
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-1-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-1-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-1-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-2-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-2-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-2-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi      
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-3-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-3-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-3-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-4-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-4-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-4-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-5-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-5-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-5-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-6-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-6-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-6-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-7-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-7-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-7-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-8-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-8-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-8-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi      
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: upf-9-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 100Mi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/upf-9-data"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: upf-9-pv-claim
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-1-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node1:Genoa RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node1:Genoa RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node1:Genoa RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node1:Genoa RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-2-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node2:Milan RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node2:Milan RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node2:Milan RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node2:Milan RtA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-3-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node3:Turin RrA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node3:Turin RrA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node3:Turin RrA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node3:Turin RrA"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-4-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node4:Genoa RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node4:Genoa RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node4:Genoa RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node4:Genoa RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-5-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node5:Milan RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node5:Milan RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node5:Milan RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node5:Milan RtB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-6-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node6:Turin RrB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node6:Turin RrB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node6:Turin RrB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node6:Turin RrB"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-7-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node7:Genoa RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node7:Genoa RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node7:Genoa RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node7:Genoa RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-8-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node8:Milan RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node8:Milan RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node8:Milan RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node8:Milan RtC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-9-configmap
  #namespace: astrid-kube
data:
  logstash.yml: |
        config.reload:
            automatic: true
            interval: 5s
        http.host: "0.0.0.0"
  pipelines.yml: |
          - pipeline.id: bau
            path.config: "/usr/share/logstash/pipeline/polycube_bau.conf"
          - pipeline.id: bau_and_warn
            path.config: "/usr/share/logstash/pipeline/polycube_bau_and_warn.conf"
          - pipeline.id: dns_bau
            path.config: "/usr/share/logstash/pipeline/polycube_dns_bau.conf"
          - pipeline.id: dns_warn
            path.config: "/usr/share/logstash/pipeline/polycube_dns_warn.conf"
  polycube_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30001
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_bau_and_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30002
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "ntp_packets_total"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "ntp_mode_private_packets_total"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "NTP", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }
  polycube_dns_bau.conf: |
   input {
       http{
         host => "127.0.0.1"
         port => 30003
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                   '
                   code => '
                           bau = []
                           warn = [ 0 ]
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0
                                                          bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
      }
  polycube_dns_warn.conf : | 
   input {
       http{
         host => "127.0.0.1"
         port => 30004
       }
   }
   
   filter {
           prune {
                   whitelist_names => "ingress-metrics"
           }
   
           mutate {
                   add_field => {
                           "timestamp" => "123456789"
                           "node_id" => "node9:Turin RrC"
                           #"use_case" => [ {
                           #       "id" => "NTP"
                           #       "bau" => [ 0 ]
                           #       "warn" => [ 0 ]
                           #} ]
                   }
           }
   
           ruby {
                   init => '
                           @old_bau = [0]
                           @tmp_bau = [0]
                           @old_warn = [0]
                           @tmp_warn = [0]
                   '
                   code => '
                           bau = []
                           warn = []
                           timestamp = 0
   
                           event_code = event.get( "ingress-metrics" )
   
                           if event_code != nil
                                   event_code.each do |elem|
                                           if elem[ "name" ] == "Total DNS packets"
                                                   @tmp_bau = elem[ "value" ]
                                                   bau << ( @tmp_bau[0] - @old_bau[0] )
                                                   if bau[0] < 0 
                                                           bau[0] = 0
                                                   end
                                                   @old_bau = @tmp_bau
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                           if elem[ "name" ] == "Total DNS queries of type ANY"
                                                   @tmp_warn = elem[ "value"]
                                                   warn << ( @tmp_warn[0] - @old_warn[0] ) 
                                                   if warn[0] < 0 
                                                           warn[0] = 0
                                                   end
                                                   @old_warn = @tmp_warn
                                                   timestamp = elem[ "timestamp" ].to_s
                                           end
                                   end
   
                                   event.set( "timestamp", timestamp )
                                   event.set( "use_case", [ Hash[ "id", "DNS", "bau", bau, "warn", warn ] ] )
   
                                   event.remove( "ingress-metrics" )
   
                                   json_message = event.to_json
   
                                   new_json_message = "\""
                                   json_message.each_char { |c|
                                           if c == "\""
                                                   new_json_message << "\\"
                                           end
                                           new_json_message << c
                                   }
                                   new_json_message << "\""
   
                                   event.set( "message", new_json_message )
                                   event.set( "host", "" )
   
                           else
                                   event.cancel
   
                           end
                   '
           }
   
   }
   
   output {
           kafka {
                   codec => plain
                   topic_id => "AstridProxyReadData"
                   bootstrap_servers => "kafka-service:9092"
                   message_key => '"%{[timestamp]}"'
                   #event['message'] => "event['message']"
           }
   }

  scheduler.sh : |
    #!/bin/sh
    set -e

    polling=$POLLING_TIME

    read_and_send() {
      response_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau/metrics' --max-time 2)
      response_bau_and_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/ntp_bau_and_warn/metrics' --max-time 2 )
      response_dns_bau=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_bau/metrics' --max-time 2 )
      response_dns_warn=$(curl -s 'http://localhost:9000/polycube/v1/dynmon/dns_warn/metrics' --max-time 2 )

      echo "response_bau: "$response_bau
      echo "response_bau_and_warn: "$response_bau_and_warn
      echo "response_dns_bau: "$response_dns_bau
      echo "response_dns_warn: "$response_dns_warn

      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30001' -d "${response_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30002' -d "${response_bau_and_warn}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30003' -d "${response_dns_bau}"
      curl -H "content-type: application/json" -XPUT -s 'http://127.0.0.1:30004' -d "${response_dns_warn}"
    }

    while true
    do
      read_and_send &
      echo "wait for "$polling" second..."
      sleep $polling
    done
